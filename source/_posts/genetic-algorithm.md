---
title: 现代启发式算法（一）——遗传算法
date: 2017-09-13 16:12:53
tags:
- 遗传算法
categories:
- 数学逻辑和算法
---
带你入门遗传算法，解读遗传算法的实现过程，通过求解TSP和mTSP问题加深对遗传算法的理解，你会发现遗传其实很有趣~
<!--more-->
# 一、概述

在阅读本文之前，可以先阅读这两篇文章（[文章1](http://blog.csdn.net/emiyasstar__/article/details/6938608/)，[文章2](http://blog.csdn.net/b2b160/article/details/4680853/)），不需要理解理论部分，概览全文，着重看一下原文举的例子，有助于理解遗传算法的实现原理。

前面的理论部分看不懂没有关系，后面有很详细的实例说明，把例子看懂并自己动手敲个代码（源码我会上传，但一定要自己亲自去实现一下，这样才能对遗传算法的每一步以及参数的意义有深刻的认识），再回过头来看遗传算法的理论部分，相信遗传算法你就入门了。

标准遗传算法的步骤如下：

1. 构造满足约束条件的染色体。由于遗传算法不能直接处理解空间中的解,所以必须通过编码将解表示成适当的染色体。实际问题的染色体有多种编码方式,染色体编码方式的选取应尽可能的符合问题约束,否则将影响计算效率。

2. 随机产生初始群体。初始群体是搜索开始的一组染色体,其数量应适当选择。

3. 计算每个染色体的适应度。适应度是反应染色体优劣的唯一指标,遗传算法就是要寻求适应度最大的染色体。

4. 使用复制、交叉和变异算子产生子群体。这三个算子是遗传算法的基本算子,其中复制体现了优胜劣汰的自然规律,交叉体现了有性繁殖的思想,变异体现了进化过程中基因突变。

5. 重复步骤,直到满足终止条件为止。

![](http://img.blog.csdn.net/20170914110548947)

从生物学角度简单来说，每一个染色体就代表一个个体，N个个体形成一个种群，计算每一个个体的适应度大小，从种群中挑选适应度大的个体，进行遗传、交叉、变异操作生成下一代种群。

从数学角度出发，上面的话翻译下来的意思就是说对某个待解决的问题先生成N个初始解，形成一个解集。计算每一个解的好坏，留下好的解，对留下的解进行一番倒腾，再生成一组解，不断循环，最后解集中的解趋近于理想值。

遗传算法是一种复杂度为O(n)的并行全局搜索算法。

与传统方法相比,遗传算法的优越性主要表现在首先,在遗传算子的作用下,遗传算法具有很强的搜索能力,能以很大的概率找到问题的全局最优解其次,由于它固有的并行性,能有效处理大规模的优化问题。

# 二、求解TSP问题

前面理论和优点说了一大堆，遗传算法到底该怎么用呢？下面通过解决TSP问题，我们来看看如何将问题转化，进而使用遗传算法求解（掌握思想最重要，用什么语言无所谓，我这里使用Matlab，不用担心不会Matlab，我会很详细的解释每一行代码的作用，然后你用自己会的语言实现一遍就可以了）。

旅行商问题（即TSP问题）指一个商人要经过且只经过一次指定的N座城市，即遍历这N座不同的城市，求最短的遍历路径。这是一个NP-hard问题，随着城市数量的增多，使用穷举法计算的复杂度为O(n!)，想要求得精确解是不切合实际的。

遗传算法求解思想：我给每一个城市一个特定编号行不行，1->2就代表从城市1到城市2，如果现在有5个城市，旅行商从城市0出发，那么0-1-2-3-4-5-0就是旅行商的一条可选路线，也就是我们TSP问题的一个解，而路径的长度就是对应的适应度值。使用遗传算法的对应术语来说，0-1-2-3-4-5-0就是一个染色体，一个个体；一个染色体里面的每一个数字就是一个基因，接下来的遗传、交叉、变异就是针对基因进行操作。Matlab里面randperm（n）函数可以生成1-n的随机全排列，调用该函数10次，就会生成10个解（父代），根据适应度值我们按照一定的策略从父代中选择10个作为子代，对子代进行遗传、交叉、变异操作，即变化染色体中基因点的位置，生成新的解，经过多次迭代，种群中的解都会趋向于某个最优解。

#### 第一步：编码

这里我们使用自然数编码，代码的14-19行是初始化种群的过程，通过randperm生成需要城市数的随机全排列，把出发城市放两端，这样一个解就构造出来了，循环指定的次数生成需要的种群大小。

#### 第二步：遗传算法迭代

代码20-28行是遗传算法的迭代过程，第21行计算适应度，第22-24行分别进行选择、交叉、变异操作。

```matlab
% 单旅行商问题的遗传算法  
% 20个城市，1条线路  
clear,clc  
close all  
load city_distance.mat  %载入距离矩阵  
load city_location.mat  
City_Number=20;         %城市数量  
Race_Number=200;        %种群数量  
Iteration=100;          %迭代次数  
P_Cross=0.8;            %交叉概率  
P_Mutation=0.2;         %变异概率  
race=zeros(Race_Number,City_Number+2);  
%初始化种群  
for i=1:Race_Number                           
    temp=randperm(City_Number);  
    route=[City_Number+1,temp,City_Number+1];  
    route=ga_hamilton(route);        %使用改良圈算法优化初始种群  
    race(i,:)=route;  
end  
for t=1:Iteration  
    adaptation=ga_adaptation(race);         %计算适应度大小  
    race=ga_choose(race,adaptation);        %进行选择操作  
    race=ga_cross(race,P_Cross);            %进行交叉操作  
    race=ga_mutation(race,P_Mutation);      %进行变异操作  
    [path,val]=ga_plot(race);  
    pause(0.1);  
    fprintf('第%d代,最优解为%d\n',t,val);  
end 
```

![](http://img.blog.csdn.net/20170914110315973)

![](http://img.blog.csdn.net/20170914110322397)

遗传算法每次求得的结果不尽相同，求解的效率也和设置的参数相关，迭代时可进行的遗传操作也多种多样，所以遗传算法是一种很自由的算法。不同于传统方法有固定的求解套路，只要核心思路没错，遗传算法的每一个步骤都是可以自定义的。我在ga_mutation函数中采取的变异操作是单点变异，即随机取两点，交换基因；在ga_cross函数中采取的交叉操作是顺序交叉（具体的交叉操作和解释可以参考[交叉算子](http://blog.csdn.net/u012750702/article/details/54563515)这篇博客）；在ga_choose函数中采取的选择策略是精英选择策略。如果你下载了源码，文件夹里还有一个ga_select函数，这是赌轮盘选择。如果你对比求解TSP和mTSP的主函数，你会发现mTSP主函数中多了，ga_exchange和ga_invert两个操作，不是说遗传算法只有遗传、交叉、变异三个操作吗，你怎么五个？其实这里不是三个操作，而是三类操作，每一类中你又可以使用多种方法，目的是为了保证种群的多样性，从而使搜索到全局最优解的概率更大。所以说遗传算法没有固定的套路，算法的自由度很大，只有适合的方法才是最好的。


# 三、求解mTSP问题

回过头来看看求解TSP的过程，是不是特别简单，你完全不用考虑最终结果是怎么计算出来的，你只要告诉遗传算法怎么进行下一步就行。

事实上，遗传算法的难点在于：

1. 如何将复杂问题转化成可用遗传算法求解的问题；

2. 寻找合适的编码方式；

3. 建立恰当的适应度值评价方法。

在学会求解TSP问题的基础上，我们加大难度，现在依然有N座城市，要求M个旅行商遍历N座城市，使总路程最短。这就是mTSP问题，不再是一条线路了，而是多条线路，而且总距离要最短。你可以先花几分钟自己思考一下，让你用遗传算法求解，你要怎么做，如何转化问题是关键。

遗传算法求解思想：

1. 依然给每座城市一个编号，方便我们使用自然数编码。假设现在有6座城市，旅行商从0点出发。那么0-1-2-3-0-4-5-6-0就是我们的一个解，为了更方便地表示，我们可以假设一个虚拟城市7，即假设两个旅行商分别从两个不同的城市出发，而这两个城市位置坐标一致，从而上面的解可表示为0-1-2-3-7-4-5-6-0。这样一来我们就把mTSP问题转化成了一个TSP问题，不同的地方就是城市数量增加了1，由6座城市，增加为7座。这样转换的便利性是显而易见的，除去端点，中间数的序列又是一组1-n的全排列，我们只要做稍许变化，就可以继续调用解决TSP问题的函数代码；

2. 到这里遗传算法的三个难点我们已经解决了编码和转化这两个难点，还剩最重要的计算适应度值。如果依旧按照求解TSP的方法把距离作为计算适应度的指标，在求解mTSP问题时会出现0-7的情形，从出发点直接回到终点，即两条线路一条特别长，另一条特别短，这明显不是我们希望得到的结果，所以在计算适应度值时要综合考虑距离和路线长度两个指标。在ga_adaptation函数中，代码16行我取两段路线长度的最大值作为另一个指标，总体适应度即两个指标之和。如果你认为两条线路长度一致比较重要，你可以增大代码16行中的系数，反之减小比例系数。

```matlab
% 多旅行商问题的遗传算法  
% 20个城市，2条线路  
clear,clc  
close all  
load city_distance.mat  
load city_location.mat  
City_Number=21;         %城市数量  
Race_Number=200;        %种群数量  
Iteration=200;          %迭代次数  
P_Cross=0.6;            %交叉概率  
P_Mutation=0.2;         %变异概率  
race=zeros(Race_Number,City_Number+2);  
%初始化种群  
for i=1:Race_Number                           
    temp=randperm(City_Number);  
    route=[City_Number+1,temp,City_Number+1];  
    route=ga_hamilton(route);         %使用改良圈算法优化初始种群  
    race(i,:)=route;  
end  
for t=1:Iteration  
    adaptation=ga_adaptation(race);  
    race=ga_choose(race,adaptation);  
    race=ga_cross(race,P_Cross);  
    race=ga_mutation(race,P_Mutation);  
    race=ga_exchange(race,P_Cross);     %新增操作  
    race=ga_invert(race,P_Cross);       %新增操作  
    [path,val]=ga_plot(race);  
    best_path=path;  
    best_value=val;  
    pause(0.1);  
end  
```
```matlab
function [ adaptation ] = ga_adaptation( race )  
    load city_distance.mat  
    k=race(1,1);  
    [m,n]=size(race);  
    adaptation=zeros(1,m);  
    adaptation_1=zeros(1,m);  
    adaptation_2=zeros(1,m);  
    for i=1:m  
        path=0;  
        for j=1:n-1  
            path=path+city_distance(race(i,j),race(i,j+1));  
        end  
        path=path+city_distance(race(i,n),race(i,1));  
        adaptation_1(i)=path;  
        index=find(race(i,:)==k-1);  
        adaptation_2(i)=max(index-1,n-index)*3000;      %系数3000不是一个固定的值，需要根据实际情况取值  
        adaptation(i)=adaptation_1(i)+adaptation_2(i);  
    end  
end  
```
![](http://img.blog.csdn.net/20170914121433162)

遗传算法每一步可选择的方法非常丰富，所以遗传算法理论简单，实现复杂。
编码方法：二进制编码，浮点数编码，自然数编码，格雷码。

选择策略：赌轮盘法，精英策略，最优保存策略。

交叉操作：顺序交叉，部分匹配交叉，循环交叉，单点交叉。

变异操作：均匀变异，边界变异，高斯近似变异。

# 四.总结
遗传算法的理论非常简单，而实际在使用中，每一个步骤和参数都是要仔细考虑的。以求解mTSP问题为模板，可以用遗传算法求解其它许多复杂的VRP问题，具体问题需要你自己去探索如何解决咯~
如果你自己动手实现过，你会发现当城市数量较少时，遗传算法还可以得到较为理想的结果，当城市数量增加时，结果可能就不那么理想了，这个时候你就需要优化你的算法细节；你也可能遇到遗传算法过早收敛，即"早熟"的问题。凡事入门简单，精通却很难，想要真正熟练使用遗传算法还需要不断学习和实践。
遗传算法具有很强的全局搜索能力，但是局部搜索能力不足，即当解接近最优解时，在最优解附件徘徊而取不到最优解。解决该问题的方法之一是混合遗传算法和模拟退火算法，模拟退火算法有很强的局部搜索能力，可由遗传算法提供一个近似最优解，然后由模拟退火算法继续搜索，从而弥补遗传算法局部搜索能力不足的缺点。
 
遗传算法的特点：

1. 遗传算法对问题参数的代码集起作用,而不是对参数本身起作用。遗传算法处理的对象是染色体,因而要求把所要优化问题的基本参数转化为定长的有限符号的染色体。

2. 遗传算法是从初始群体开始搜索的,而不是从单点开始搜索的。许多传统优化方法都是从搜索空间的单点出发,通过某些转换规则确定下一点。这种点到点的搜索方法在多峰值优化问题中,首先找到的可能不是最优峰值，遗传算法是以点集开始的寻优过程,初始群体是随机在搜索空间中选取的,这样在搜索过程中达到最优峰值的概率大于点到点的概率。

3. 遗传算法在搜索过程中只使用适应度函数,而不用导数及其他辅助信息。对于不同类型的优化问题具有广泛适应性。

4. 遗传算法使用概率转换规则而不用确定性规则。遗传算法使用概率转换规则来调整其搜索方向,各代群体间没有统一的联系规律。但使用概率转换规则并不意味着这种方法属于随机算法范畴,它只是使用随机转换作为工具来调整搜索过程趋向于目标函数不断改进的区域。

如需源码可访问[GitHub](https://github.com/Nirvana-cn/Genetic_Algorithm)下载